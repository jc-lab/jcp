//
// Created by jichan on 2019-08-20.
//

#include <iostream>
#include <jcp/security.hpp>
#include <jcp/asn1/x9/x9_object_identifiers.hpp>
#include <jcp/key_utils.hpp>

#include <jcp/pkcs8_encoded_key_spec.hpp>
#include <jcp/key_factory.hpp>
#include <jcp/key_factory_algo.hpp>

#include <jcp/ec_private_key.hpp>
#include <jcp/rsa_private_key.hpp>

#include <jcp/mbedcrypto_provider.hpp>
#include <jcp/openssl_provider.hpp>
#include <jcp/x509_encoded_key_spec.hpp>

#include <jcp/key_pair_generator.hpp>
#include <jcp/key_pair_algo.hpp>

#if 1

int main() {
	jcp::MbedcryptoProvider::registerTo(jcp::Security::getInstance());
	jcp::OpensslProvider::registerTo(jcp::Security::getInstance());

    if(1)
    {
        // Key pair generator
        std::unique_ptr<jcp::KeyPairGenerator> kpg = jcp::KeyPairGenerator::getInstance(jcp::KeyPairAlgorithm::EC_prime256v1.algo_id());
        kpg->initialize(0, nullptr);
        jcp::Result<jcp::KeyPair> result_kp = kpg->genKeyPair();
        if(result_kp) {
            std::vector<unsigned char> priv_key = result_kp->getPrivateKey()->getEncoded();
            std::vector<unsigned char> pub_key  = result_kp->getPublicKey()->getEncoded();
            std::cout << "Success key pair generator" << std::endl;

            printf("Private Key (%s) : ", result_kp->getPrivateKey()->getFormat().c_str());
            for(int i=0; i<priv_key.size();i++) {
                printf("%02x ", priv_key[i]);
            }
            printf("\n");
            printf("Public Key (%s) : ", result_kp->getPublicKey()->getFormat().c_str());
            for(int i=0; i<pub_key.size();i++) {
                printf("%02x ", pub_key[i]);
            }
            printf("\n");
        }else{
            std::cout << "Failed key pair generator" << std::endl;
        }
    }
    if(0)
    {
        // Key pair generator
        std::unique_ptr<jcp::KeyPairGenerator> kpg = jcp::KeyPairGenerator::getInstance("RSA");
        kpg->initialize(1024, nullptr);
        jcp::Result<jcp::KeyPair> result_kp = kpg->genKeyPair();
        if(result_kp) {
            std::vector<unsigned char> priv_key = result_kp->getPrivateKey()->getEncoded();
            std::vector<unsigned char> pub_key  = result_kp->getPublicKey()->getEncoded();
            std::cout << "Success key pair generator" << std::endl;

            printf("Private Key (%s) : ", result_kp->getPrivateKey()->getFormat().c_str());
            for(int i=0; i<priv_key.size();i++) {
                printf("%02x ", priv_key[i]);
            }
            printf("\n");
            printf("Public Key (%s) : ", result_kp->getPublicKey()->getFormat().c_str());
            for(int i=0; i<pub_key.size();i++) {
                printf("%02x ", priv_key[i]);
            }
            printf("\n");
        }else{
            std::cout << "Failed key pair generator" << std::endl;
        }
    }
	if(0)
    {
        unsigned char temp_1[] =
            {0x30, 0x81, 0x87, 0x02, 0x01, 0x00, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x04, 0x6d, 0x30, 0x6b, 0x02, 0x01, 0x01, 0x04, 0x20, 0xa8, 0x2d, 0xe2, 0x54, 0xd8, 0xbb, 0x96, 0x07, 0xbe, 0x6f, 0x98, 0x28, 0x0e, 0x62, 0xe7, 0xa7, 0xaa, 0x32, 0x09, 0xb0, 0xd5, 0xa2, 0x75, 0xca, 0xca, 0xff, 0x61, 0x95, 0xbc, 0x5e, 0x3b, 0xcf, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x92, 0x64, 0x11, 0x93, 0xe0, 0xa1, 0x8d, 0x41, 0xbd, 0xeb, 0x90, 0x46, 0xdf, 0xff, 0x2f, 0x5c, 0xee, 0x7d, 0xe5, 0xbb, 0x30, 0x11, 0xc6, 0x18, 0x08, 0x62, 0xe3, 0x73, 0x27, 0x02, 0x69, 0x37, 0x47, 0xf7, 0x98, 0x0c, 0xa4, 0x91, 0x97, 0xd5, 0x26, 0x18, 0x62, 0xca, 0x5a, 0xf2, 0x11, 0xd7, 0xe8, 0xd1, 0x27, 0x3a, 0xcc, 0xee, 0x81, 0xae, 0x60, 0x97, 0x59, 0x63, 0xcf, 0x5b, 0xbd, 0xe3};
        unsigned char temp_2[] =
            {0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x92, 0x64, 0x11, 0x93, 0xe0, 0xa1, 0x8d, 0x41, 0xbd, 0xeb, 0x90, 0x46, 0xdf, 0xff, 0x2f, 0x5c, 0xee, 0x7d, 0xe5, 0xbb, 0x30, 0x11, 0xc6, 0x18, 0x08, 0x62, 0xe3, 0x73, 0x27, 0x02, 0x69, 0x37, 0x47, 0xf7, 0x98, 0x0c, 0xa4, 0x91, 0x97, 0xd5, 0x26, 0x18, 0x62, 0xca, 0x5a, 0xf2, 0x11, 0xd7, 0xe8, 0xd1, 0x27, 0x3a, 0xcc, 0xee, 0x81, 0xae, 0x60, 0x97, 0x59, 0x63, 0xcf, 0x5b, 0xbd, 0xe3};


        std::unique_ptr<jcp::KeyFactory> keyFactory = jcp::KeyFactory::getInstance("PKCS8");

        {
            jcp::Result<std::unique_ptr<jcp::PKCS8EncodedKeySpec>>
                result = jcp::PKCS8EncodedKeySpec::decode(temp_1, sizeof(temp_1));

            std::cout << "exception : " << result.exception() << std::endl;
            if (result) {
                std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
                std::cout << "key : " << key.get() << std::endl;
                std::cout << "key : " << key->getFormat() << std::endl;
                std::cout << "key : " << key->getAlgorithm() << std::endl;

                jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
                jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
                std::cout << "private_key : " << private_key->get() << std::endl;
                std::cout << "public_key : " << public_key->get() << std::endl;
            }
        }
        std::cout << " ___ " << std::endl;
        {
            jcp::Result<std::unique_ptr<jcp::X509EncodedKeySpec>>
                result = jcp::X509EncodedKeySpec::decode(temp_2, sizeof(temp_2));

            std::cout << "exception : " << result.exception() << std::endl;
            if (result) {
                std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
                std::cout << "key : " << key.get() << std::endl;
                if(key) {
                    std::cout << "key : " << key->getFormat() << std::endl;
                    std::cout << "key : " << key->getAlgorithm() << std::endl;
                }
                jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
                jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
                std::cout << "private_key : " << private_key->get() << std::endl;
                std::cout << "public_key : " << public_key->get() << std::endl;
            }
        }
    }

	std::cout << " ----------------------- " << std::endl;

#if 0
	{

		unsigned char temp_1[] =
		{ 0x30, 0x41, 0x02, 0x01, 0x00, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08,
		 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x04, 0x27, 0x30, 0x25, 0x02, 0x01, 0x01, 0x04, 0x20, 0x61,
		 0x1b, 0x6d, 0xcd, 0x8b, 0x56, 0x3b, 0x5c, 0xbe, 0x73, 0x11, 0x5d, 0xfc, 0xf5, 0xf5, 0x18, 0x05, 0xbf, 0xe1,
		 0xe5, 0xf8, 0x34, 0x1f, 0xcb, 0xed, 0xe4, 0x75, 0x84, 0x2b, 0x05, 0xf4, 0x2c }; 
		unsigned char temp_2[] =
		{ 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x92, 0x64, 0x11, 0x93, 0xe0, 0xa1, 0x8d, 0x41, 0xbd, 0xeb, 0x90, 0x46, 0xdf, 0xff, 0x2f, 0x5c, 0xee, 0x7d, 0xe5, 0xbb, 0x30, 0x11, 0xc6, 0x18, 0x08, 0x62, 0xe3, 0x73, 0x27, 0x02, 0x69, 0x37, 0x47, 0xf7, 0x98, 0x0c, 0xa4, 0x91, 0x97, 0xd5, 0x26, 0x18, 0x62, 0xca, 0x5a, 0xf2, 0x11, 0xd7, 0xe8, 0xd1, 0x27, 0x3a, 0xcc, 0xee, 0x81, 0xae, 0x60, 0x97, 0x59, 0x63, 0xcf, 0x5b, 0xbd, 0xe3 };


		std::unique_ptr<jcp::KeyFactory> keyFactory = jcp::KeyFactory::getInstance("PKCS8");

		{
			jcp::Result<std::unique_ptr<jcp::PKCS8EncodedKeySpec>>
				result = jcp::PKCS8EncodedKeySpec::decode(temp_1, sizeof(temp_1));

			std::cout << "exception : " << result.exception() << std::endl;
			if (result) {
				std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
				std::cout << "key : " << key.get() << std::endl;
				std::cout << "key : " << key->getFormat() << std::endl;
				std::cout << "key : " << key->getAlgorithm() << std::endl;

                jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
                jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
				std::cout << "private_key : " << private_key->get() << std::endl;
				std::cout << "public_key : " << public_key->get() << std::endl;
			}
		}
		std::cout << " ___ " << std::endl;
		{
			jcp::Result<std::unique_ptr<jcp::X509EncodedKeySpec>>
				result = jcp::X509EncodedKeySpec::decode(temp_2, sizeof(temp_2));

			std::cout << "exception : " << result.exception() << std::endl;
			if (result) {
				std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
				std::cout << "key : " << key.get() << std::endl;
				if (key) {
					std::cout << "key : " << key->getFormat() << std::endl;
					std::cout << "key : " << key->getAlgorithm() << std::endl;
				}
                jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
                jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
				std::cout << "private_key : " << private_key->get() << std::endl;
				std::cout << "public_key : " << public_key->get() << std::endl;
			}
		}
	}

	std::cout << " ----------------------- " << std::endl;

    {
        unsigned char temp_1[] =
            {0x30, 0x41, 0x02, 0x01, 0x00, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08,
             0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x04, 0x27, 0x30, 0x25, 0x02, 0x01, 0x01, 0x04, 0x20, 0x61,
             0x1b, 0x6d, 0xcd, 0x8b, 0x56, 0x3b, 0x5c, 0xbe, 0x73, 0x11, 0x5d, 0xfc, 0xf5, 0xf5, 0x18, 0x05, 0xbf, 0xe1,
             0xe5, 0xf8, 0x34, 0x1f, 0xcb, 0xed, 0xe4, 0x75, 0x84, 0x2b, 0x05, 0xf4, 0x2c};

		std::unique_ptr<jcp::KeyFactory> keyFactory = jcp::KeyFactory::getInstance("PKCS8");

		{
			jcp::Result<std::unique_ptr<jcp::PKCS8EncodedKeySpec>>
				result = jcp::PKCS8EncodedKeySpec::decode(temp_1, sizeof(temp_1));

			std::cout << "exception : " << result.exception() << std::endl;
			if (result) {
				std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
				std::cout << "key : " << key.get() << std::endl;
				std::cout << "key : " << key->getFormat() << std::endl;
				std::cout << "key : " << key->getAlgorithm() << std::endl;

				jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
				jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
				std::cout << "private_key : " << private_key->get() << std::endl;
				std::cout << "public_key : " << public_key->get() << std::endl;
			}
		}

    }
	std::cout << " ----------------------- " << std::endl;
    {
        unsigned char temp_1[] =
            {0x30, 0x82, 0x02, 0x78, 0x02, 0x01, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01,
             0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x02, 0x62, 0x30, 0x82, 0x02, 0x5E, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81,
             0x00, 0xA7, 0xD4, 0x96, 0xDE, 0x46, 0x1B, 0x45, 0x58, 0x1C, 0x4C, 0xDC, 0x43, 0xD1, 0x76, 0x99, 0x42, 0xE1,
             0xFA, 0x64, 0xD5, 0x11, 0x65, 0x39, 0xAF, 0xE0, 0x60, 0x67, 0x1F, 0x91, 0x0E, 0x19, 0x82, 0xB1, 0x29, 0xBC,
             0xC2, 0x68, 0x42, 0xF6, 0x02, 0x8E, 0x45, 0x04, 0x83, 0xD4, 0x6A, 0xCE, 0x73, 0xDE, 0x5A, 0x49, 0x99, 0x38,
             0x81, 0x41, 0xF6, 0x4A, 0xE9, 0xAE, 0x6C, 0xA9, 0x17, 0x64, 0x7D, 0x7C, 0x4D, 0x51, 0x97, 0x3F, 0x8B, 0x9D,
             0xBC, 0x6B, 0x03, 0x64, 0x0C, 0x53, 0x63, 0x56, 0x3B, 0x41, 0x34, 0x71, 0x6F, 0x74, 0x56, 0x7B, 0x20, 0xDF,
             0x83, 0xB2, 0xF9, 0x2E, 0x2C, 0xB7, 0x6C, 0x41, 0x3C, 0x6C, 0xD7, 0x22, 0x9C, 0x37, 0x9E, 0x17, 0x0D, 0xFE,
             0x4A, 0xAC, 0x11, 0xC4, 0x02, 0xDF, 0x72, 0x7E, 0x38, 0x31, 0x27, 0xBF, 0xA3, 0x1D, 0x55, 0x02, 0x79, 0xE8,
             0x7B, 0xE6, 0xC9, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x81, 0x81, 0x00, 0x91, 0xF2, 0x05, 0xEC, 0x6E, 0xEC,
             0xC2, 0x25, 0xB8, 0x1E, 0x82, 0xA1, 0x1B, 0x22, 0xD6, 0x6E, 0x5A, 0x13, 0x23, 0xE2, 0x41, 0x89, 0x54, 0x5C,
             0x04, 0x73, 0xF0, 0xD9, 0x7B, 0x8B, 0xD6, 0x55, 0x57, 0x78, 0xE3, 0x23, 0xF0, 0x04, 0xE2, 0xE8, 0x20, 0x0E,
             0x16, 0xBA, 0x09, 0x5B, 0x84, 0x03, 0x30, 0xC6, 0x35, 0x20, 0x60, 0x09, 0xCF, 0x71, 0xBD, 0x7D, 0x6E, 0xE8,
             0x21, 0x37, 0x2D, 0x73, 0xA5, 0x26, 0x4E, 0xA2, 0xEE, 0xE2, 0xDA, 0xE0, 0xC6, 0x6F, 0xFA, 0x1B, 0x7F, 0x81,
             0x04, 0xD3, 0x92, 0xB4, 0xF4, 0x80, 0xCD, 0xFC, 0xA7, 0x25, 0x47, 0xBB, 0xF3, 0x7B, 0xBE, 0x89, 0x76, 0xF2,
             0xAF, 0x9C, 0xD8, 0x41, 0x33, 0x8E, 0x4B, 0x13, 0xDE, 0x26, 0x13, 0x67, 0x2F, 0x65, 0xF3, 0x80, 0xDE, 0xC1,
             0x3A, 0x6D, 0x84, 0xA7, 0x80, 0x40, 0xE6, 0x36, 0xEF, 0x69, 0x0A, 0x84, 0xEC, 0x31, 0x02, 0x41, 0x00, 0xDB,
             0xD8, 0xBF, 0xF4, 0x29, 0x68, 0xF1, 0x46, 0x58, 0xF2, 0x4F, 0xA1, 0xD0, 0x5B, 0xF6, 0x8C, 0xB2, 0xBD, 0xF0,
             0x00, 0x5F, 0xEB, 0xB1, 0xEF, 0xF1, 0xD3, 0x83, 0x6B, 0xC5, 0x33, 0xE4, 0xF4, 0x17, 0x56, 0x3B, 0xB2, 0x58,
             0x7B, 0x04, 0xE4, 0xC0, 0x1B, 0x1F, 0xE4, 0xD4, 0xE7, 0x5C, 0xA9, 0x0D, 0x70, 0xA7, 0x6D, 0xAF, 0x71, 0x70,
             0x4C, 0x9A, 0x54, 0x6F, 0xAD, 0xDB, 0xD9, 0x3E, 0xA5, 0x02, 0x41, 0x00, 0xC3, 0x6E, 0x06, 0x6D, 0x25, 0x1A,
             0x80, 0xFF, 0xB7, 0x31, 0x02, 0xAF, 0x2B, 0x18, 0xC8, 0x74, 0x21, 0xC8, 0x59, 0x06, 0x88, 0x3E, 0x82, 0x1E,
             0xB7, 0xFC, 0x6F, 0x77, 0x0C, 0x91, 0x3F, 0xD6, 0xA1, 0x8E, 0xB9, 0xBE, 0x49, 0xF5, 0x81, 0xB7, 0xED, 0x9B,
             0xC9, 0x1A, 0xD8, 0x10, 0x3B, 0xEF, 0xE5, 0x12, 0x0D, 0xD9, 0x90, 0x33, 0xFB, 0x33, 0xC0, 0x42, 0x70, 0xBD,
             0x43, 0x20, 0x92, 0x55, 0x02, 0x40, 0x3A, 0x0B, 0x2D, 0x0A, 0xF2, 0xCF, 0xF1, 0x3B, 0xC8, 0x8A, 0x19, 0x3A,
             0x38, 0xBF, 0xBF, 0x05, 0x80, 0xBF, 0xA3, 0x19, 0x06, 0x3A, 0x3D, 0x5D, 0x83, 0x74, 0x7B, 0xB3, 0x3D, 0x7A,
             0xA9, 0x0D, 0x45, 0x08, 0x10, 0x74, 0xD2, 0xE5, 0x8F, 0xF2, 0x31, 0x42, 0x38, 0x16, 0x7B, 0x9B, 0xA6, 0x1C,
             0x40, 0x1F, 0x29, 0x25, 0x4D, 0x77, 0xDE, 0xD5, 0x6A, 0xBD, 0xB6, 0x4A, 0xA9, 0xCB, 0xDE, 0xBD, 0x02, 0x41,
             0x00, 0xB7, 0x1E, 0xC4, 0x94, 0xC6, 0xFC, 0x93, 0xBD, 0x89, 0x09, 0x3A, 0x8B, 0xAA, 0xA5, 0x59, 0x47, 0x40,
             0x54, 0x7B, 0xDE, 0xDC, 0x11, 0x3E, 0x59, 0xCC, 0x6A, 0x94, 0x83, 0x87, 0xDA, 0x1E, 0x68, 0x5E, 0x0F, 0xDF,
             0xCA, 0x07, 0x81, 0x2D, 0x60, 0x8C, 0x1B, 0xBA, 0x90, 0x15, 0xBE, 0xF8, 0x7A, 0xAC, 0x39, 0x83, 0x92, 0xC6,
             0x45, 0x7E, 0xEF, 0x9A, 0x0A, 0x67, 0x9B, 0x60, 0x68, 0x07, 0xD5, 0x02, 0x41, 0x00, 0xCE, 0x11, 0x32, 0x2B,
             0x27, 0x93, 0x6B, 0xC4, 0x03, 0x9D, 0x05, 0x82, 0x52, 0xDF, 0x1B, 0x01, 0xA7, 0x60, 0x2D, 0x07, 0xAC, 0x9E,
             0x82, 0x30, 0xC6, 0xFA, 0x1E, 0x9B, 0x45, 0xA5, 0xC9, 0x45, 0xAD, 0xD4, 0x6A, 0x2B, 0xBB, 0x68, 0x08, 0xE6,
             0x93, 0x34, 0x9D, 0x99, 0x8B, 0x02, 0x74, 0x19, 0x64, 0x04, 0x6B, 0x8C, 0x94, 0x67, 0xA0, 0x01, 0x1E, 0x6B,
             0xA2, 0x6F, 0x01, 0x13, 0x1C, 0x8D};

		std::unique_ptr<jcp::KeyFactory> keyFactory = jcp::KeyFactory::getInstance("PKCS8");

		{
			jcp::Result<std::unique_ptr<jcp::PKCS8EncodedKeySpec>>
				result = jcp::PKCS8EncodedKeySpec::decode(temp_1, sizeof(temp_1));

			std::cout << "exception : " << result.exception() << std::endl;
			if (result) {
				std::unique_ptr<jcp::AsymKey> key = (*result)->generateParsedKey();
				std::cout << "key : " << key.get() << std::endl;
				std::cout << "key : " << key->getFormat() << std::endl;
				std::cout << "key : " << key->getAlgorithm() << std::endl;

                jcp::Result<std::unique_ptr<jcp::AsymKey>> private_key = keyFactory->generatePrivateKey(result->get());
                jcp::Result<std::unique_ptr<jcp::AsymKey>> public_key = keyFactory->generatePublicKey(result->get());
				std::cout << "private_key : " << private_key->get() << std::endl;
				std::cout << "public_key : " << public_key->get() << std::endl;
			}
		}
    }
#endif
    //jcp::internal::PKCS8Reader pkcs8Reader;
    //pkcs8Reader.test(temp_1, sizeof(temp_1));
    return 0;
}
#endif

#if 0

#include <jcp/provider.hpp>
#include <jcp/asym_key.hpp>

#include <jcp/cipher.hpp>
#include <jcp/gcm_param_spec.hpp>
#include <jcp/message_digest.hpp>
#include <jcp/mac.hpp>
#include <jcp/key_agreement.hpp>
#include <jcp/signature.hpp>

#include <jcp/pbe_key_spec.hpp>

using namespace jcp;

void printHexBytes(const void *ptr, int len) {
    const unsigned char* cptr = (const unsigned char*)ptr;
    int i;
    for (i = 0; i < len; i++) {
        printf("%02x ", cptr[i]);
    }
    printf("\n");
}

int main() {
    // Hmac Test
    if (1)
    {
        std::unique_ptr<Mac> md(Mac::getInstance("HmacSHA256"));
        SecretKey macKey((const unsigned char*)"abcd", 4);
        md->init(&macKey);
        md->update("abcdefg", 7);
        md->update("1234", 4);
        jcp::Result<Buffer> digest = md->digest();
        printf("doFinal : "); printHexBytes(&digest->data()[0], digest->size());

        // 39646d8e7cc8f48310089caa891aaede962a054aac9b38feeafac6d00ea1c85c
        // TEST OK
    }

    // Message Digest SHA test
    if (1)
    {
        std::unique_ptr<MessageDigest> md(MessageDigest::getInstance("SHA-256"));
        md->update("abcdefg", 7);
        md->update("1234", 4);
        jcp::Result<Buffer> digest = md->digest();
        printf("doFinal : "); printHexBytes(&digest->data()[0], digest->size());

        // a5fece454cbf03ada21e1de86dbc705af674ae029dac95a027b5ce5f9bdfd10f
        // TEST OK
    }

    // AES/GCM Test
    if (1)
    {
        std::vector<unsigned char> ciphertext;

        {
            std::unique_ptr<Cipher> cipher(Cipher::getInstance("AES/GCM/NoPadding"));
            SecretKey encKey((const unsigned char*)"0123456789abcdef", 16);
            jcp::Result<Buffer> result_with_buffer;

            cipher->init(Cipher::ENCRYPT_MODE, &encKey, GCMParameterSpec::create(128, (uint8_t*)"0000000000000000", 16).get());
            cipher->updateAAD("auth_1234", 9);
            result_with_buffer = cipher->update("abcd", 4);
            std::cout << "ENCRYPTING : " << std::endl;
            if (result_with_buffer->size() > 0) {
                printHexBytes(&result_with_buffer->data()[0], result_with_buffer->size());
                ciphertext.insert(ciphertext.end(), result_with_buffer->data(), result_with_buffer->data() + result_with_buffer->size());
            }
            result_with_buffer = cipher->doFinal();
            std::cout << "ENCRYPTING(FINAL) : " << std::endl;
            if (result_with_buffer->size() > 0) {
                printHexBytes(&result_with_buffer->data()[0], result_with_buffer->size());
                ciphertext.insert(ciphertext.end(), result_with_buffer->data(), result_with_buffer->data() + result_with_buffer->size());
            }
        }

        std::cout << "CIPHER TEXT : " << std::endl;
        printHexBytes(ciphertext.data(), ciphertext.size());
        // ad0f07ed e997dd8608e0205be4f5f8621fcf652e
        // ENCRYPTION TEST OK


        {
            std::unique_ptr<Cipher> cipher(Cipher::getInstance("AES/GCM/NoPadding"));
            SecretKey encKey((const unsigned char*)"0123456789abcdef", 16);
            jcp::Result<Buffer> result_with_buffer;

            cipher->init(Cipher::DECRYPT_MODE, &encKey, GCMParameterSpec::create(128, (uint8_t*)"0000000000000000", 16).get());
            cipher->updateAAD("auth_1234", 9);
            result_with_buffer = cipher->update(ciphertext.data(), ciphertext.size());
            std::cout << "DECRYPTING : " << std::endl;
            if (result_with_buffer->size() > 0) {
                printHexBytes(&result_with_buffer->data()[0], result_with_buffer->size());
                ciphertext.insert(ciphertext.end(), result_with_buffer->data(), result_with_buffer->data() + result_with_buffer->size());
            }
            result_with_buffer = cipher->doFinal();
            std::cout << "DECRYPTING(FINAL) : excep(" << (result_with_buffer->exception() ? "true" : "false") << ") : " << std::endl;
            printHexBytes(&result_with_buffer->data()[0], result_with_buffer->size());
        }

        // DECRYPTION TEST OK
    }

    // PBKDF2 Test
    if (1) {
        unsigned char salt[] = "SALT1234";

        const jcp::SecretKeyFactory* factory = jcp::SecretKeyFactory::getInstance("PBKDF2WithHmacSHA1");
        jcp::PBEKeySpec keySpec("PASSWORD", 8, salt, 8, 1000, 128);
        jcp::Result<SecretKey> result = factory->generateSecret(&keySpec);
        std::cout << "ENCODED : " << std::endl;
        printHexBytes(result->getEncoded().data(), result->getEncoded().size());
        // 77 27 25 72 63 fe 4f a3 77 38 be 1b 3b 04 42 ab
        // TEST OK
    }

    return 0;
}
#endif